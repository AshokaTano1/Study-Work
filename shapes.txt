import os
from .serializers import *
from .models import *
from django.contrib.auth import authenticate, login, logout
from django.http import JsonResponse
from django.middleware.csrf import get_token
from rest_framework.permissions import IsAuthenticated
import json
import requests
from rest_framework.decorators import api_view, permission_classes
from loguru import logger
from django.urls import resolve

def GetGateToken():
    data = {
        'grant_type': 'client_credentials',
        'client_id': os.environ["CLIENT_ID"],
        'client_secret': os.environ["CLIENT_SECRET"]
    }
    try:
        response = requests.post(f"{os.environ['GATE_ADDR']}/oauth2/token/", data=data)
        return response.json()['access_token']
    except Exception as e:
        return f'Ошибка получения данных из Шлюза: {e}'

def GetFolderStructure(folder, user):
    # Получаем ссылки, принадлежащие текущей папке
    folders = []
    links = []
    for link in Link.objects.filter(inFolder=folder, user=user):
        links.append({
            'id': f'link-{link.id}',
            'title': link.title,
            'w': link.w,
            'h': link.h,
            'y': link.y,
            'dashboardX': link.dashboardX,
            'color': link.color,
            'border': link.border,
            'font': link.font,
            'description': link.description,
            'url': link.url,
            'gateFileHash': link.gateFileHash,
            'gateCheckFile': link.gateCheckFile
        })
    # Получаем дочерние папки
    for child in Folder.objects.filter(inFolder=folder, user=user):
        folders.append(GetFolderStructure(child, user))
    return {
        'id': f'folder-{folder.id}',
        'title': folder.title,
        'w': folder.w,
        'h': folder.h,
        'y': folder.y,
        'dashboardX': folder.dashboardX,
        'color': folder.color,
        'border': folder.border,
        'font': folder.font,
        'description': folder.description,
        'links': links,
        'folders': folders
    }

@api_view(['GET'])
@permission_classes([IsAuthenticated])  
def SendDataView(request, **kwargs):
    '''
    Функция, которая передаёт JSON-объект плиток всех пользователя вида:
    {
        "id":"",
        "folders": [
            "id":"folder-1",
            "folders": [
                ...
            ],
            "links": [
                {
                "id":"link-3",
                "url":"..."
                },
                {
                "id":"link-4",
                "url":"..."
                }
            ]
        ] 
        "links": [
            {
            "id":"link-1",
            "url":"..."
            },
            {
            "id":"link-2",
            "url":"..."
            }
        ]
    }
    '''
    try:
        '''
        В полученном аргументе функции, который является URL, проверяется 
        принадлежность к URL-классу "shared"
        '''
        if resolve(request.path_info).url_name == 'shared' and 'user' in kwargs:
            shared = UserSettings.objects.get(user__username=kwargs['user'])
            if shared.shared:
                user = shared.user.id
            else:
                return JsonResponse({'error': f'Ошибка доступа'})
        else:
            user = request.user.id
        structure = []
        folders = []
        links = []
        # Перемещает все ссылки, у которых infolder указывает на главную страницу (None)
        for link in Link.objects.filter(inFolder=None, user=user):
            links.append({
                'id': f'link-{link.id}',
                'title': link.title,
                'w': link.w,
                'h': link.h,
                'y': link.y,
                'dashboardX': link.dashboardX,
                'color': link.color,
                'border': link.border,
                'font': link.font,
                'description': link.description,
                'url': link.url,
                'gateFileHash': link.gateFileHash,
                'gateCheckFile': link.gateCheckFile
            })
        # Перемещает все папки, у которых infolder указывает на главную страницу
        for folder in Folder.objects.filter(inFolder=None, user=user):
            folders.append(GetFolderStructure(folder, user))
        structure.append({
            'id': '',
            'links': links,
            'folders': folders
        }) 
        return JsonResponse({"data": json.dumps(structure, indent=4, ensure_ascii=False)}, safe=False)
    except Exception as e:
        return JsonResponse({"error": f"Ошибка получения данных ссылок пользователя {user} из БД: {e}"}, safe=False)

#Функция для проверки аутентификации пользователя
def SessionView(request, format=None):
    if request.user and not request.user.is_anonymous and request.user.is_active:
        return JsonResponse({'isAuthenticated': True})
    else:
        return JsonResponse({'isAuthenticated': False})

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def SharedList(request, format=None):
    try:
        sharedUsers = []
        for user in UserSettings.objects.filter(shared=True):
            sharedUsers.append({
                'url': user.user.username,
                'username': user.customName or f'{user.user.last_name} {user.user.first_name}'
            })
        return JsonResponse({'data': sharedUsers})
    except Exception as e:
        return JsonResponse({'error': f'{e}'})

@api_view(['GET'])
@permission_classes([IsAuthenticated])
# Возвращает параметры пользователя
def WhoamiView(request, format=None):
    settings = UserSettings.objects.get(user=request.user)
    return JsonResponse({'username': request.user.username, 'first_name': request.user.first_name, 'last_name': request.user.last_name, 'is_admin': request.user.is_staff, 'gateUUID': settings.gateUUID, 'settings': {
        'theme': settings.theme,
        'days': settings.days,
        'gateAllUpdate': settings.gateAllUpdate,
        'alwaysYesterday': settings.alwaysYesterday,
        'gateTabOpen': settings.gateTabOpen
    }})

@api_view(['POST'])
@permission_classes([IsAuthenticated])
# Получает информацию о настройках и сохраняет их в БД
def SettingsCallbackView(request, format=None):
    try:
        UserSettings.objects.filter(user=request.user.id).update(theme=request.data['data']['theme'], days=request.data['data']['days'], gateAllUpdate=request.data['data']['gateAllUpdate'], alwaysYesterday=request.data['data']['alwaysYesterday'], gateTabOpen=request.data['data']['gateTabOpen'])
        return JsonResponse({'data': 'Данные сохранены'})
    except Exception as e:
        return JsonResponse({'error': {e}})

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def AutoCopyListView(request, format=None):
    try:
        tasks = []
        for task in AutoCopyTask.objects.all():
            tasks.append({
                "id": task.id,
                "userFrom": f"{task.userFrom.last_name} {task.userFrom.first_name}",
                "userTo": f"{task.userTo.last_name} {task.userTo.first_name}"
            })
        return JsonResponse({'tasks': tasks})
    except Exception as e:
        return JsonResponse({'error': f'{e}'})

def FindFolderInData(data, id: str):
    for item in data:
        if item['id'] == id:
            return item
        found = FindFolderInData(item.get('folders', []), id)
        if found:
            return found
    return None

def CreateDeleteOrUpdateRecords(model, user, data, folder):
    # Поиск уже созданных значений в конкретной папке
    existingRecordsDict = {record.id: record for record in model.objects.filter(user=user, inFolder=folder).in_bulk().values()}
    for item in data:
        item.pop('added', None)
        item.pop('gateFileHash', None)
        item.pop('gateFileUpdated', None)
        item.pop('x', None)
        if "new" in item['id']:
            item.pop('id', None)
            item['user'] = user
            item['inFolder'] = folder
            model.objects.create(**item)
        else:
            id = int(item['id'].split('-')[-1])
            item.pop('id', None)
            record = existingRecordsDict[id]
            for field, value in item.items():
                setattr(record, field, value)
            record.save()
            del existingRecordsDict[id]
    # Удаление оставшихся элементов из БД, если они не были обновлены
    for id in existingRecordsDict:
        existingRecordsDict[id].delete()
    
@api_view(['POST'])
@permission_classes([IsAuthenticated])
# Сохраняет плитки в БД
def SaveDataView(request):
    try:
        data = request.data['data']
        # Текущая папка
        currentFolder = None
        user = User.objects.get(id=request.user.id)
        # Определяем текущую папку
        # Если пришло None, то перезаписывается вся главная папка 
        # Если пришёл id, то перезаписывается только папка с этим id и её дочерние объекты
        if "id" in request.data and "folder" in request.data['id']:
            currentFolder = Folder.objects.get(user=request.user.id, id=request.data['id'].split('-')[-1])
            folderData = FindFolderInData(data, request.data['id'])
            if folderData:
                folders = folderData['folders']
                links = folderData['links']
            else:
                return JsonResponse({"error": "Неверные данные"}, safe=False)
        else:
            folders = data[0]['folders']
            links = data[0]['links']
        # Создаёт, удаляет или редактирует записи в БД (папки) согласно передаваемым параметрам
        CreateDeleteOrUpdateRecords(Folder, user, folders, currentFolder)
        # Создаёт, удаляет или редактирует записи в БД (сылки) согласно передаваемым параметрам
        CreateDeleteOrUpdateRecords(Link, user, links, currentFolder)
        return JsonResponse({"detail": "Плитки успешно сохранены"}, safe=False)
    except Exception as e:
        logger.error(f"Ошибка сохранения данных: {e}") 
        return JsonResponse({'error': f"Ошибка сохранения данных: {e}"}) 

@api_view(['POST'])
@permission_classes([IsAuthenticated])  
def SendGateData(request):
    try:
        token = GetGateToken()
        return JsonResponse({'token': token}) 
    except Exception as e:
        return JsonResponse({'error': f'{e}'})
    
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def GateOpenCallback(request):
    try:
        if 'url' in request.data and 'hash' in request.data:
            Link.objects.filter(url=request.data['url']).update(gateFileHash=request.data['hash'])
        return JsonResponse({'data': 'Запись хэша файла внесена'}) 
    except Exception as e:
        return JsonResponse({'error': f'{e}'}) 

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def LogCallback(request):
    try:
        Logs.objects.create(user=User.objects.get(id=request.user.id), time=request.data['data']['time'], url=request.data['data']['url'], text=request.data['data']['text'], ip=request.META.get('HTTP_X_FORWARDED_FOR'))
        return JsonResponse({'detail': 'Запись внесена'})
    except Exception as e:
        return JsonResponse({'error': f'{e}'}) 

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def UsersList(request):
    if request.user.is_staff:
        users = []
        for user in User.objects.all():
            try:
                settings = UserSettings.objects.get(user=user)
                users.append({
                    'id': user.id,
                    'username': user.username,
                    'fio': f"{user.last_name} {user.first_name}",
                    'is_staff': user.is_staff,
                    'last_login': user.last_login.strftime("%Y-%m-%d %H:%M:%S"),
                    'is_active': user.is_active,
                    'gateUUID': True if settings.gateUUID else False
                })
            except UserSettings.DoesNotExist:
                logger.error(f'Отсутствуют настройки для пользователя {user.username}')
        return JsonResponse({'data': users})
    return JsonResponse({'error': f'Отказано в доступе'}) 

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def LogsList(request):
    if request.user.is_staff:
        try:
            usernames = []
            for user in User.objects.filter(logs__isnull=False).distinct():
                usernames.append({
                    "fio": f"{user.last_name} {user.first_name}",
                    "username": user.username
                })
            return JsonResponse({'usernames': usernames})
        except Exception as e:
            return JsonResponse({'error': f'Ошибка: {e}'}) 
    return JsonResponse({'error': f'Отказано в доступе'})

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def LogView(request):
    if request.user.is_staff:
        try:
            logs = []
            for log in Logs.objects.filter(user=User.objects.get(username=request.data['username'])):
                logs.append({
                    "time": log.time,
                    "text": log.text,
                    "url": log.url,
                    "ip": log.ip
                })
            return JsonResponse({'log': logs})
        except Exception as e:
            return JsonResponse({'error': f'Ошибка: {e}'}) 
    return JsonResponse({'error': f'Отказано'}) 


# Функция копирования профиля
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def ProfileCopy(request):
    if request.user.is_staff:
        try:
            userFrom = User.objects.get(username=request.data['copyFrom'])
            userTo = User.objects.get(username=request.data['copyTo'])
            idTab = request.data.get('idTab', None)#добавлен idTab 
            copy_profile(userTo, userFrom)
            

            if idTab is None:
                return JsonResponse({'error': 'idTab не передан в запросе'})#добавлен idTab 

            
            if request.data['autoCopy']:
                try:
                    AutoCopyTask.objects.create(userFrom=userFrom, userTo=userTo)
                except:
                    return JsonResponse({'detail': f'Профиль "{userFrom.last_name} {userFrom.first_name}" успешно скопирован, но задача для "{userTo.last_name} {userTo.first_name}" уже существует',
                    'idTab': idTab})#добавлен idTab 

            return JsonResponse({'detail': f'Профиль "{userFrom.last_name} {userFrom.first_name}" успешно скопирован', 'idTab':idTab})#добавлен idTab 
        except Exception as e:
            return JsonResponse({'error': f'Ошибка: {e}'}) 
    return JsonResponse({'error': f'Отказано'}) 
        

# Запросы, на получение CSRF токена и аутентификацию
def GetCSRFTokenView(request):
    response = JsonResponse({'detail': 'CSRF cookie установлены'})
    response['X-CSRFToken'] = get_token(request)
    return response

# API входа в систему
def LoginView(request, **kwargs):
    try:
        data = json.loads(request.body)
        username = data.get('username')
        password = data.get('password')
        remember = data.get('remember')
        if username is None or password is None:
            return JsonResponse({'error': 'Пожалуйста, предоставьте логин и пароль'}, status=400)
        user = authenticate(username=username, password=password)
        if user is None:
            return JsonResponse({'error': 'Неверный логин или пароль'}, status=400)
        if not remember:
            request.session.set_expiry(0)
        login(request, user)
        try:
            token = GetGateToken()
            headers = {'Authorization': 'Bearer ' + token}
            data = {
                'username': username
            }
            response = requests.post(f"{os.environ['GATE_ADDR']}/api/user/get_uuid/", headers=headers, data=data)
            user, created = UserSettings.objects.get_or_create(user=user)
            UserSettings.objects.filter(user=request.user.id).update(gateUUID=response.json()['data']['uuid'])
        except Exception as e:
            logger.error(f"Пользователь {username} не может получить данные от Шлюза: {e}")
        return JsonResponse({'detail': 'Успешный вход'})
    except Exception as e:
        return JsonResponse({'error': f'Ошибка входа: {e}'}, status=400)
    
# Выход из системы
def LogoutView(request):
    if not request.user.is_authenticated:
        return JsonResponse({'detail': 'Вы не вошли в систему'}, status=400)
    logout(request)
    return JsonResponse({'detail': 'Успешный выход'})
