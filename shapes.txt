export interface Plitka {
  added: boolean,
  id: string;
  title: string;
  description: string | undefined;
  url: string | undefined;
  dashboardX: number;
  x: number | undefined;
  y: number;
  w: number;
  h: number;
  folders: Plitka[] | undefined;
  links: Plitka[] | undefined;
  color: string;
  border: {
    color: string;
    style: string;
    size: number;
  },
  font: {
    color: string;
    style: string;
  },
  gateFileHash: string | undefined;
  gateCheckFile: boolean | undefined;
  gateFileUpdated: boolean | undefined
}

export interface Hash {
  date: string,
  url: string,
  hash: string | undefined
}

@Injectable({
  providedIn: 'root'
})
export class GateService {
  public hashes: BehaviorSubject<Hash[]> = new BehaviorSubject<Hash[]>([]);
  public downloadProgress: number  = 0;

  constructor(private backend: BackendService, private plitkiService: PlitkiService, private notifications: NotificationsService , private fileService: GateFileService, private userService: UserService, private networkService: NetworkService) { }

  updateHashes(array: Hash[]): Hash[] {
    // Создаем объект для быстрого доступа к новым элементам по url
    const newItemsMap = new Map<string, string | undefined>();
    // Заполняем карту новыми элементами
    array.forEach(item => {
        newItemsMap.set(item.url, item.hash);
    });
    // Обновляем старый массив
    const updatedArray = this.hashes.value.map(item => {
        // Если элемент существует в новом массиве, обновляем его значение
        if (newItemsMap.has(item.url)) {
            return { date: item.date, url: item.url, hash: newItemsMap.get(item.url)};
        }
        // Если элемент не найден в новом массиве, оставляем его без изменений
        return item;
    });
    // Добавляем новые элементы из нового массива, которых нет в старом
    array.forEach(item => {
        if (!this.hashes.value.some(oldItem => oldItem.url === item.url)) {
            updatedArray.push(item);
        }
    });
    return updatedArray;
  }

  base64toBlob(base64Data: any, contentType: any) {
    contentType = contentType || '';
    var sliceSize = 1024;
    var byteCharacters = atob(base64Data);
    var bytesLength = byteCharacters.length;
    var slicesCount = Math.ceil(bytesLength / sliceSize);
    var byteArrays = new Array(slicesCount);
  
    for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
        var begin = sliceIndex * sliceSize;
        var end = Math.min(begin + sliceSize, bytesLength);
  
        var bytes = new Array(end - begin);
        for (var offset = begin, i = 0; offset < end; ++i, ++offset) {
            bytes[i] = byteCharacters[offset].charCodeAt(0);
        }
        byteArrays[sliceIndex] = new Uint8Array(bytes);
    }
    return new Blob(byteArrays, { type: contentType });
  }

  async getAvailableGateFiles(choosenDate: Date) {
      let ids: any[] = []
      let date = moment(choosenDate).format("YYYY MM DD").split(' ')
      let year = date[0]
      let month = date[1]
      let day = date[2]

      let collectedIDs = this.plitkiService.collectIDs().filter(function(elem, index, self) {
        return index === self.indexOf(elem);
      })

      for (const id of collectedIDs) 
        if (await this.fileService.getGateFile(`${id}-${year}-${month}-${day}`) === null)
          ids.push(id)
      
      if (ids.length > 0) {
        this.getGateFiles(ids, {
          year: year,
          month: month,
          day: day
        }).then( (data: any) => {
          if (data)
            if (data.error)
              this.notifications.showError(data.error)
        })
      }
  }

  async getOrClearGateFilesHash(clear: boolean) {
    if(!clear) {
      this.getGateFilesHash(this.plitkiService.collectIDs().filter(function(elem, index, self) {
        return index === self.indexOf(elem);
      })).then ((hashes) => {
        if(hashes) {
          this.hashes.next(this.updateHashes(hashes))
        }
      })
    } else {
      this.hashes.next([])
    }
  }

  async getGateData(){
    return axios.post(`${import.meta.env.NG_APP_API_URL}/gate/data/`, {},
    {
      headers: {
        "X-CSRFToken": await this.backend.getcsrftoken()
      },
      withCredentials: true
    })
    .then((response: any) => {
      return response.data
    })
    .catch((error: any) => {
      return error
    });
  }

  async getGateListFiles() {
    let data = await this.getGateData()
    let user = await this.userService.whoami()
    return axios.post(`${import.meta.env.NG_APP_GATE_URL}/api/files/list/`, {"uuid": user.gateUUID},
    {
        headers: {
          'Authorization': 'Bearer ' + data.token
        }
    })
    .then((response: any) => {
      return response.data.files
    })
    .catch((error: any) => {
    });
  }
  /**
  * Получает со Шлюза файлы по заданным ID.
  * @since v0.2.4
  * @param ids массив ID.
  * @param date структура даты {year, month, day}
  */
  async getGateFiles(ids: any[], date: any) {
    let data = await this.getGateData()
    let user = await this.userService.whoami()
    let count = 100 / ids.length
    for (const id of ids) {
      await axios.post(`${import.meta.env.NG_APP_GATE_URL}/api/files/get/?year=${date.year}&month=${date.month}&day=${date.day}`, {"uuids": [user.gateUUID], "id": id},
      {
        headers: {
          'Authorization': 'Bearer ' + data.token
        }
      })
      .then((response: any) => {
        this.fileService.saveGateFile(response.data.filename, this.base64toBlob(response.data.data.split(',')[1], response.data.data.match(/^data:(.*?);base64,(.*)$/)[1]))
        this.downloadProgress! += count
      })
      .catch((error: any) => {
        return error;
      });
    }
    this.downloadProgress = 0
  }

  async getGateFilesHash(ids: any[]) {
    let data = await this.getGateData()
    return axios.post(`${import.meta.env.NG_APP_GATE_URL}/api/files/hashes/`, {"ids": JSON.stringify(ids)},
    {
      headers: {
        'Authorization': 'Bearer ' + data.token
      }
    })
    .then((response: any) => {
      return response.data.hashes
    })
    .catch((error: any) => {
    });
  }


  
  async openGateFileCallback(hash: any, url: any) {
    return axios.post(`${import.meta.env.NG_APP_API_URL}/gate/callback/`, {"hash": hash, "url": url},
    {
      headers: {
        "X-CSRFToken": await this.backend.getcsrftoken()
      },
      withCredentials: true
    })
    .then((response: any) => {
      return response.data
    })
    .catch((error: any) => {
    });
  }
}

@Injectable({
  providedIn: 'root'
})
export class PlitkiService {

  public dashboard: Plitka[][] = []; // Плитки текущей страницы
  public data: any[] = []; 
  column: BehaviorSubject<number> = new BehaviorSubject<number>(8);

  constructor(private backend: BackendService, private storage: StorageMap) { }

  collectIDs() {
    const ids: any[] = [];

    function searchFolders(folders: any) {
      for (const folder of folders) {
        for (const link of folder.links) 
          if (link.url && link.url.startsWith(import.meta.env.NG_APP_GATE_FILE_URL)) 
            ids.push(parseInt(link.url.split('=')[1]));
        searchFolders(folder.folders);
      }
    }

    searchFolders(this.data);
    return ids;
  }

  async getPlitkiData(shared: boolean, sharedUsername: string) {
    let complited_url = undefined
    if (shared)
      complited_url = `${import.meta.env.NG_APP_API_URL}/plitki/shared/${sharedUsername}/get`
    else
      complited_url = `${import.meta.env.NG_APP_API_URL}/plitki/get`
    return axios.get(complited_url, 
    {
      headers: {
        "X-CSRFToken": await this.backend.getcsrftoken()
      },
      withCredentials: true
    })
    .then((response: any) => {
      if (!response.data.error) {
        let data = JSON.parse(response.data.data)
        if(!shared)
          this.storage.set(`data`, data).subscribe(() => {});
      return data
      } else
        return response.data
    })
    .catch((error: any) => {
      if(!shared) {
        let data = new Promise(resolve=>{
          this.storage.get('data').subscribe((data) => {
            resolve(data)
          });
        })
        if (data != undefined) {
          return data
        }
        else {
          return {
            error: "Сохраненные данные отсутствуют"
          }
        }
      } else {
        return {'error': 'Неизвестная ошибка'}
      }
    });
  }

  async savePlitkiData(data: any, shared: boolean, page: string | undefined) {
    let url = undefined
    if (shared)
      url = `${import.meta.env.NG_APP_API_URL}/plitki/shared/save/`
    else
      url = `${import.meta.env.NG_APP_API_URL}/plitki/save/`
    return axios.post(url,  { "data": data, "id": page },
      {
        headers: {
          "X-CSRFToken": await this.backend.getcsrftoken()
        },
        withCredentials: true
      })
      .then((response: any) => {
        return response.data
      })
      .catch((error: any) => {
        return {"error": "Ошибка получения данных с сервера"}
      });
  }

  async logsSend(data: any) {
    let url = `${import.meta.env.NG_APP_API_URL}/plitki/logs/callback/`
    return axios.post(url,  { "data": data},
      {
        headers: {
          "X-CSRFToken": await this.backend.getcsrftoken()
        },
        withCredentials: true
      })
      .then((response: any) => {
        return response.data
      })
      .catch((error: any) => {
        return {"error": "Ошибка отправки / получения данных с сервера"}
      });
  }

  async getLogsList() {
    let url = `${import.meta.env.NG_APP_API_URL}/plitki/logs/list/`
    return axios.get(url,
      {
        headers: {
          "X-CSRFToken": await this.backend.getcsrftoken()
        },
        withCredentials: true
      })
      .then((response: any) => {
        return response.data.usernames
      })
      .catch((error: any) => {
        return {"error": "Ошибка получения данных с сервера"}
      });
  }

  async getLog(username: string) {
    let url = `${import.meta.env.NG_APP_API_URL}/plitki/logs/view/`
    return axios.post(url, {"username": username},
      {
        headers: {
          "X-CSRFToken": await this.backend.getcsrftoken()
        },
        withCredentials: true
      })
      .then((response: any) => {
        return response.data
      })
      .catch((error: any) => {
        return {"error": "Ошибка получения данных с сервера"}
      });
  }

  async getAutoCopyList() {
    let url = `${import.meta.env.NG_APP_API_URL}/plitki/copy/list/`
    return axios.get(url,
      {
        headers: {
          "X-CSRFToken": await this.backend.getcsrftoken()
        },
        withCredentials: true
      })
      .then((response: any) => {
        return response.data
      })
      .catch((error: any) => {
        return {"error": "Ошибка получения данных с сервера"}
      });
  }

  // функция для копирования профиля с добавлением ID надо сгенерировать при помощи библиотеки айдишник 
  async profileCopy(copyFrom: string, copyTo: string, autoCopy: boolean, idTab: number) {
    let url = `${import.meta.env.NG_APP_API_URL}/plitki/copy/`
    return axios.post(url, {"copyFrom": copyFrom, "copyTo": copyTo, "autoCopy": autoCopy, "idTab": idTab},
      {
        headers: {
          "X-CSRFToken": await this.backend.getcsrftoken()
        },
        withCredentials: true
      })
      .then((response: any) => {
        return response.data
      })
      .catch((error: any) => {
        return {"error": "Ошибка получения данных с сервера"}
      });
  }

  getNewLastByTypeID(type: string, page: number): string {
    // Ищет самый большой ID, например 39, 40, 8 - 40
    if (!type.includes('new'))
      type = `new-${type}`
    let plitki = this.dashboard[page].slice().filter((el: any) => el.id.includes(type))
    let plitka: Plitka | undefined = undefined
    let maxNumber: number | undefined = undefined;
    for (const item of plitki) {
      const number = parseInt(Str(item.id).afterLast('-').get())
      if (number !== undefined && (maxNumber === undefined || number > maxNumber)) {
        maxNumber = number;
        plitka = item;
      }
    }
    if(plitka != undefined && maxNumber != undefined) {
      return `${type}-${maxNumber + 1}`
    } else
      return `${type}-0`
  }

}
